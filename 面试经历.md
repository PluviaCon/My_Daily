# 面试阿里的经历

## 电话面试

我投的这个部门效率还很算很高,周三投了,第二天就约了电话面试.

有点意外问的全是和 React 相关的内容,CSS 和 JS 的内容都没问到.

主要是性能优化和跨组件处理和 Hook 原理这块.

能记起来的问题就这些,过了.

### 项目经历和用了哪些东西

这个就很传统,问了简历里的项目用了哪些技术栈,如实回答就好.

### NodeJS 和 浏览器事件执行顺序问题

突然问题来我一时没有记起来,后来想到了这篇文章,里面有详细的解释:
[一篇文章教会你 Event loop——浏览器和 Node](https://segmentfault.com/a/1190000013861128)

### React Hook 常用钩子

常用的几个就好:

-   `useState`
-   `useEffect`
-   `useRef`
-   `useCallback`
-   `useMemo`
-   `useContext`

可以不用说第三方库的 hook 组件,没必要.

### React 的性能优化方案

-   避免没有必要的卸载和更新
-   保持标签和 DOM 结构的稳定性
-   避免重复渲染,可以使用`shouldComponentUpdate`生命周期来对比有无变化的`props`和`state`来避免组件更新,对于基本类型和引用类型的不同所带来的`shouldComponentUpdate`周期无效的情况,可以看一下[immutable](https://immutable-js.github.io/immutable-js/)的使用.`hook`组件可以使用`memo`来阻止更新.
-   分离组件,尽量避免父组件的更新.
    比如,一个父组件里有循环出来的子组件,在更新 state 改变子组件数量或者值的时候,可以把改变的过程放在子组件完成或者是在父组件时将改变后的数据赋值给一个变量传入子组件中

### 如何定位系统性能需要改进的点

大概意思就是,如果系统中存在了导致页面卡顿或者某些奇怪故障的时候,如何去定位.

-   首先对页面进行测试,找出需要定位的页面或组件
-   通过`chrome`的`Performance`选项测试页面的渲染性能
-   查看网络请求`(Network 选项卡)`,通过`time`和`size`属性排序来对比占用网络资源多的请求
-   如果是`React`应用,可以使用 React 官方插件`React Developer Tools`来比较组件的渲染次数和 state,props 的变化

### React useEffect 返回函数(销毁时)在什么时候执行

官方文档上说的很清楚:

> React 何时清除 effect? React 会在组件卸载的时候执行清除操作. 正如之前学到的, effect 在每次渲染的时候都会执行. 这就是为什么 React 会在执行当前 effect 之前对上一个 effect 进行清除. 我们稍后将讨论为什么这将助于避免 bug 以及如何在遇到性能问题时跳过此行为.

### React useEffect 内使用 state 的方式

这一点经常在项目使用中用到,原因是 setState 的异步问题.

> 组件内部的任何函数, 包括事件处理函数和 effect, 都是从它被创建的那次渲染中被「看到」的.

例如当你在上一个函数中改变了某一个`State`的状态,然后想在下一个函数中调用,却发现`State`的值没有发生改变.

解决办法大概有三个:

-   使用`useRef`来同步数据
-   使用全局变量来存储,但是复杂类型数据不建议
-   使用`Context`或全局状态组件来管理状态
-   如果是链式调用(紧接着调用)可以考虑直接传值减少`State`变化,不容易复用组件

### React Hook 的性能优化方案

Hook 组件内的优化大体和 React 优化方式相同,但是有一些更值得注意的问题:

-   避免和`class`组件书写形式一样,`state`的定义要保持简洁,避免状态定义混乱以降低耦合和复杂度
-   `Effect`定义要注意第二参数的使用,即对监听的状态尽量减少,或者拆分
-   使用`useMemo`和`useCallback`来减少组件重新渲染
-   还有一些[其他的](https://www.v2ex.com/t/724286)

### React Hook 和 Class 组件形式的区别

老问题了,大概是这几个方面,或者可以参考这篇文章: [函数式组件与类组件有何不同？](https://overreacted.io/zh-hans/how-are-function-components-different-from-classes/)

-   在代码上,定义的方式不同
-   function 组件每次渲染都会有独立 props/state,而 class 组件总是会通过 this 拿到最新的 props/state
-   function 组件逻辑复用简单, 而 class 组件逻辑复用困难
-   这也是类组件 this 存在的意义,能在渲染方法以及生命周期方法中得到最新的实例.

### 跨端 App 的实现原理

我只有`Electron`开发经验和小程序开发经验,所以只浅显的说了一下我理解的实现原理:

原生开发直接将语言编译成可执行文件, 直接调用系统 API, 完成 UI 绘制等. 这类开发技术, 有着较高的运行效率, 但一般来说, 开发速度较慢, 技术要求较高.Electron 通过将 Chromium 和 Node.js 合并到同一个运行时环境中, 并将其打包为 Mac, Windows 和 Linux 系统下的应用来实现这一目的.

其他跨平台的方案大概也是这个原理,将平台所选的语言转换为原生的语言.

### 跨端 App 有哪些劣势

也是相同的:

-   性能不如原生
-   无法热更新
-   调试困难
-   开源库受限于平台的欢迎程度
-   协作成本高

更多可以参考这篇文章: [跨端方案的三大困境](http://www.ayqy.net/blog/cross-platform-pains/)

### 前端监控怎么实现

前端监控这方面我没有具体了解过,但是和面试官说了之后,他会引导你说一下实现的思路,具体到怎么监控,监控的逻辑,没问详细的技术.

可以参考掘金的这篇文章: [前端监控的设计和实现](https://juejin.cn/post/6844904138522755080).

### 自己开源项目的实现,加了那些功能

如实回答就好,主要讲一下实现了什么功能,对原有项目做了哪些更改最好.

### 我问他问题

很简单的问题,为啥没问我 css 之类的问题,面试官说没必要,很好,我很喜欢.

### 笔试

有些问题比较简单,直接记下题目就好

```js
/**
 * 说明：生成一个指定长度（默认6位）的随机字符, 随机字符包含字母数字.
 * 输入：输入随机字符长度, 无输入默认6位
 * 输出：随机字符, 如"6bij0v"
 */
```

```js
// 在移动开发中会有触发比较频繁的事件, 比如用户滚动屏幕引起图片的懒加载等；请完成下面函数throttle
```

```js
//有一个数组, 里面只存在 _ 和 字母, 比如 [‘_‘, ‘d’, ‘c’, ‘_‘, ‘e’, ‘_‘, ‘a’, ‘*‘]. 现在需要把这个数组中的所有星号移动到左边, 所有的字母移动到右边, 所有字母的顺序不能改变.
```

```js
//创建一个 Promise Chain , 实现有序 Promise 的串行调用
```

## 二次电话面试

主要问了具体项目的实现,深入到了项目里的某一个点让你详细说明.

我主要遇到的是项目的性能优化(react 层面和网络其他层面),mobx 和 redux 对比,全局状态组件怎么实现的减少渲染来提升性能(这个说的棱模两可,实在记不住 mobx 怎么实现的精准找到需要更改的值儿不触发其他渲染的了,我还是停在了技术使用层面了).

下面先记录一下:

### umi 工程化理解(做了什么让代码变快的)

umi 是个企业级的前端框架,可以很好的和我们公司的业务匹配(多数中台),并且对旧项目代码有很高的的兼容性.

-   通过微内核架构把大量需要业务重复的代码插件化,配置即可使用,节省时间
-   组件太大时可以采用按需加载`(dynamic)`
-   可以使用`esbuild`进行压缩
-   使用`externals`属性将一些组件库排除在打包范围外,注意使用的时候需要同时引入`scripts`外部链接
-   通过配置`SplitChunks`属性,调整公共依赖的提取策略

### webpack 怎么实现的打包优化

### 项目的性能优化,除了代码层的

### React 的优化

### react hook 和 class 组件的区别,hook 的 setState 怎么实现的保存变量信息的.

### mobx 和 redux 的对比

MobX 是基于观察者/可观察模式的. 你将创建一个可观察的数据模型, 将你的组件标记为该数据的 "观察者", MobX 将自动跟踪它们访问哪些数据, 并在数据变化时重新渲染它们.

### mobx 怎么实现的精准找到需要更改的值来减少渲染

Mobx 使用了 ES 6 的`proxy`拦截变量的读取和写入,当任何对象改变时,由对象对应的`key`值来触发`autoRun`函数,实现精准触发更新.

参考-[Mobx 思想的实现原理, 及与 Redux 对比](https://zhuanlan.zhihu.com/p/25585910)

### 全局状态组件真的是可以减少渲染并带来优化吗

对于小组件来说,全局状态管理是可以避免的,也可以说不必要,因为容易造成复杂,混乱难以理解的情况.

有时候对于大组件来说,频繁的更改状态,有可能会触发子组件和父组件公用的状态,从而造成更多的渲染.mobx 做到了精准触发改变的值从而减少渲染,但也可以避免

## 上午的电话面试

问了很多项目相关的问题,还有一些基础性的.

还问了开源项目怎么实现的,这个年代久远有点忘了,只说了大概思路.

一些值得记录的问题:

### useState 怎么实现的保存 state

useState 原理,很简单, 就是利用必包返回一个 setState, 主动 render

当有多个 state 怎么处理呢, 我们的状态从全局变量 state 升级为全局数组
第一次渲染时候, 根据 useState 顺序, 逐个声明 state 并且将其放入全局 Array 中. 每次声明 state, 都要将 cursor 增加 1.

### Promise 实现原理

大概思路:

-   构造核心的方法`resolve`,`reject`
-   将 then 方法定义在 Promise 的原型上

参考:

[简单实现 Promise](https://imweb.io/topic/5bbc264b6477d81e668cc930)
[Promise 实现原理（附源码）](https://juejin.cn/post/6844903665686282253)

### generator, promise 与 async/await 的关系

-   async/await 使得异步代码看起来像同步代码
-   Generator 函数是将函数分步骤阻塞 , 只有主动调用 next() 才能进行下一步
-   async/await 就是 generator + promise 的语法糖, 还自带 auto run 的 buff

参考: [promise generator async 三者关系和区别](https://juejin.cn/post/6844904137734225933)

### 正向代理和反向代理

-   正向代理是一个位于客户端和目标服务器之间的服务器(代理服务器), 为了从目标服务器取得内容, 客户端向代理服务器发送一个请求并指定目标, 然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端.

    是"代理服务器"代理了"客户端", 去和"目标服务器"进行交互.

    通过正向代理服务器访问目标服务器, 目标服务器是不知道真正的客户端是谁的, 甚至不知道访问自己的是一个代理（有时候中介也直接冒充租客）.

-   反向代理是指以代理服务器来接受 internet 上的连接请求, 然后将请求转发给内部网络上的服务器, 并将从服务器上得到的结果返回给 internet 上请求连接的客户端, 此时代理服务器对外就表现为一个反向代理服务器.

-   正向代理其实是客户端的代理, 帮助客户端访问其无法访问的服务器资源. 反向代理则是服务器的代理, 帮助服务器做负载均衡, 安全防护等.

-   正向代理一般是客户端架设的, 比如在自己的机器上安装一个代理软件. 而反向代理一般是服务器架设的, 比如在自己的机器集群中部署一个反向代理服务器.

-   正向代理中, 服务器不知道真正的客户端到底是谁, 以为访问自己的就是真实的客户端. 而在反向代理中, 客户端不知道真正的服务器是谁, 以为自己访问的就是真实的服务器.

-   正向代理和反向代理的作用和目的不同. 正向代理主要是用来解决访问限制问题. 而反向代理则是提供负载均衡、安全防护等作用. 二者均能提高访问速度.

### JSONP 和 AJAX 的区别

-   调用方式很像,都是请求 url
-   AJAX 的核心是通过 XmlHttpRequest 获取非本页内容, 而 JSONP 的核心则是动态添加`<script>`来调用服务器提供的 js 脚本.
-   JSONP 是一种方式或者说非强制性协议, 如同 AJAX 一样, 它也不一定非要用 json 格式来传递数据, 如果你愿意, 字符串都行, 只不过这样不利于用 JSONP 提供公开服务.
-   jsonp 只支持 get 请求, ajax 支持 get 和 post 请求.

## 下午的电话面试

这个面试问的我直冒冷汗,比第二次面试还回答不上来.但是结束之后面试官还指导我去看一下文章和书补一下,还挺好的.意识到了自己的不足之处.就是有点太紧张了问的,问的好心虚自己感觉.

主要是以下问题(记得住的):

### 浏览器如何强制刷新,使页面访问时浏览的是新数据

浏览器缓存可以带来很多好处,比如减少请求负担,加快访问速度等.但是在特定场合,比如新项目上线,但是用户没有主动刷新时,会造成没有接受新资源的困扰.

要刷新浏览器的缓存,主要可以在以下几方面:

-   window.location.reload(true) 强制刷新
-   nginx 反向代理. 比如`umi`打包出来后,访问的入口文件是`index.html`,将符合文件类型的请求添加`Cache-Control`请求头,使用协商缓存.

参考: [浏览器缓存带来的前端项目更新问题及解决方法](https://blog.csdn.net/feiyu_may/article/details/88376945)

### 浏览器事件循环机制(重点)

### 前端跨域解决办法

防止跨域请求是可以减少跨域攻击这是事实.在没有`CORS`之前,同源策略也是为了阻止不同来源加载资源的读取.

跨源资源共享（CORS）是一种机制,允许通过网络控制对网页上子资源的访问.

前端设置方法:

-   设置`Access-Control-Allow-Origin`请求头
-   设置`Access-Control-Allow-Method`请求头

CORS 标准新增了一组 http 首部字段, 允许服务器声明哪些源站通过浏览器可以访问哪些资源. 另外, 规范要求, 对那些可能对服务器数据产生副作用的请求, 必须首先使用 options 方法发起预检请求, 获知服务端是否允许该跨域请求, 允许之后才发起实际的 HTTP 请求, 在预检返回的结果中, 服务端也可以通知客户端是否需要携带身份凭证（cookies 和 http 认证相关数据）.

参考:

[Deep dive in CORS: History, how it works, and best practices](https://ieftimov.com/post/deep-dive-cors-history-how-it-works-best-practices/)
[CORS 跨域时, 为何会出现一次动作, 两次请求？](https://juejin.cn/post/6844903765363916814)

### 前端安全问题,如何防范

存储型指的是恶意代码提交到了网站的数据库中, 当用户请求数据的时候, 服务器将其拼接为 HTML 后返回给了用户, 从而导致了恶意代码的执行.

反射型指的是攻击者构建了特殊的 URL, 当服务器接收到请求后, 从 URL 中获取数据, 拼接到 HTML 后返回, 从而导致了恶意代码的执行.

DOM 型指的是攻击者构建了特殊的 URL, 用户打开网站后, js 脚本从 URL 中获取数据, 从而导致了恶意代码的执行.

对于第一个方面, 如果我们对存入数据库的数据都进行的转义处理, 但是一个数据可能在多个地方使用, 有的地方可能不需要转义, 由于我们没有办法判断数据最后的使用场景, 所以直接在输入端进行恶意代码的处理, 其实是不太可靠的.

因此我们可以从浏览器的执行来进行预防, 一种是使用纯前端的方式, 不用服务器端拼接后返回. 另一种是对需要插入到 HTML 中的代码做好充分的转义. 对于 DOM 型的攻击, 主要是前端脚本的不可靠而造成的, 我们对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断.

还有一些方式, 比如使用 CSP , CSP 的本质是建立一个白名单, 告诉浏览器哪些外部资源可以加载和执行, 从而防止恶意代码的注入攻击.

参考:

[这一次, 彻底理解 XSS 攻击](https://juejin.cn/post/6912030758404259854#heading-2)

### react 有没有做 xss 安全防范问题,怎么做的

React DOM 在渲染所有输入内容之前, 默认会进行转义,所有内容在渲染之前被转换成了字符串,确保恶意代码不会被执行.

具体转义方式:

-   将`"'&<>`特殊符号转义成 html 字符
-   利用 React.createElement()函数返回 ReactElement 特性,每次 DOM 渲染后都有一个`$$typeof`属性来标识是否是原来代码中渲染的 DOM 元素.
    如果通过代码注入的形式修改或直接创建一个新的 DOM,React 利用这个属性来防止通过构造特殊的 Children 来进行的 XSS 攻击, 原因是 `$$typeof` 是个 `Symbol` 类型, 进行 JSON 转换后会 Symbol 值会丢失, 无法在前后端进行传输.
-   React 里`dangerouslySetInnerHTML`属性的使用,谨慎使用,没有什么渲染是不能用结构改变+样式解决不掉的.

参考:

[浅谈 React 中的 XSS 攻击](https://juejin.cn/post/6874743455776505870#heading-8)

### Promise 怎么实现顺序执行,不依赖新特性或语法糖(不用 async 或 promise.all promise.reduce 之类的)

### forIn forOf 区别,forIn 有什么坑

### umi 框架的选择(第三次了),为什么

### 为什么 class 组件就比 hook 组件(函数式组件)好(重点)

> 再详细描述一下,面试官问的是,class 组件也可以做到不复杂的逻辑,也可以做到 hook 组件做到的事情,**为什么**一定要升级到 hook 组件

灵魂问题,我回答的都反驳了,弄得我自己也怀疑为什么我要升级组件了,从这里还是冒汗了.
